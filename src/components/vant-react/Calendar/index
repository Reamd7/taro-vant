import Taro, { useState, useMemo, useCallback, useEffect, useRef } from "@tarojs/taro";

import "./index.less";
import dayjs from "dayjs";
import VanPopup, { VanPopupProps } from "../Popup";
import { Block, View, ScrollView } from "@tarojs/components";
import VanToast from "../Toast";
import VanCalHeader from "./components/header";
import VanCalMonth from "./components/month";
import VanButton from "../Button";
import { useMemoClassNames, useScope } from "../common/utils";
import { Toast } from "../Toast/toast";

type inputDate = dayjs.ConfigType;
type VanCalendarCommonProps = {
  title?: string;
  color?: string;
  show?: boolean;
  formatter?: VoidFunction;
  confirmText?: string;
  rangePrompt?: string;
  allowSameDay?: boolean;
  confirmDisabledText?: string;
  minDate?: inputDate;
  maxDate?: inputDate;
  position?: VanPopupProps['position'];
  rowHeight?: number | string;
  round?: VanPopupProps['round'];
  poppable?: boolean;
  showMark?: boolean;
  showTitle?: boolean;
  showConfirm?: boolean;
  showSubtitle?: boolean;
  safeAreaInsetBottom?: boolean;
  closeOnClickOverlay?: VanPopupProps['closeOnClickOverlay'];
  maxRange?: number;
  // ======================================
  renderTitle?: React.ReactNode;
  renderFooter?: React.ReactNode;
}
export type VanCalendarProps = VanCalendarCommonProps & (
  {
    type?: "single"
    defaultDate?: inputDate
    onUnSelect?: (date: dayjs.Dayjs) => unknown;
    onSelect?: (date: dayjs.Dayjs) => unknown;
    onConfirm?: (date: dayjs.Dayjs) => unknown;
  } | {
    type: "range"
    defaultDate?: [inputDate, inputDate]
    onUnSelect?: (date: [dayjs.Dayjs, dayjs.Dayjs | null]) => unknown;
    onSelect?: (date: [dayjs.Dayjs, dayjs.Dayjs | null]) => unknown;
    onConfirm?: (date: [dayjs.Dayjs, dayjs.Dayjs | null]) => unknown
  } | {
    type: "multiple"
    defaultDate?: inputDate[]
    onUnSelect?: (date: dayjs.Dayjs[]) => unknown;
    onSelect?: (date: dayjs.Dayjs[]) => unknown
    onConfirm?: (date: dayjs.Dayjs[]) => unknown
  }
);

const ROW_HEIGHT = 64;

const VanCalendar: Taro.FunctionComponent<VanCalendarProps> = (props) => {
  const {
    title = "日期选择",
    confirmText = "确定",
    type = "single",
    minDate = (Date.now()),
    maxDate = (new Date(
      new Date().getFullYear(),
      new Date().getMonth() + 6,
      new Date().getDate()
    )),
    position = "bottom",
    rowHeight = ROW_HEIGHT,
    round = true,
    poppable = true,
    showMark = true,
    showTitle = true,
    showConfirm = true,
    showSubtitle = true,
    safeAreaInsetBottom = true,
    closeOnClickOutside = true,
  } = props;

  const minDay = useMemo(() => dayjs(minDate), [minDate]);
  const maxDay = useMemo(() => dayjs(maxDate), [maxDate]);

  // 获取初始值
  const getInitialDate = useMemo(() => {
    if (props.type === 'range') {
      if (props.defaultDate) {
        const [startDay, endDay] = props.defaultDate
        return [
          dayjs(startDay),
          dayjs(endDay)
        ] as [dayjs.Dayjs, dayjs.Dayjs]
      } else {
        return [
          minDay,
          minDay.add(1, 'day')
        ] as [dayjs.Dayjs, dayjs.Dayjs]
      }
    } else if (props.type === "multiple") {
      if (props.defaultDate) {
        return props.defaultDate.map(val => dayjs(val))
      } else {
        return [minDay] as dayjs.Dayjs[]
      }
    } else {
      if (props.defaultDate) {
        return [dayjs(props.defaultDate)]
      } else {
        return [minDay]
      }
    }
  }, [props.type, props.defaultDate, minDay]);


  const getMonths = useCallback((minDate: inputDate, maxDate: inputDate) => {
    const months: Array<[dayjs.Dayjs, number]> = [];
    let cursor = dayjs(minDate).set("date", 1)
    do {
      months.push([cursor, cursor.daysInMonth()])
      cursor = cursor.clone().add(1, "month")
    } while (
      cursor.isAfter(maxDate)
    )
    return months
  }, [])
  const monthslist = useMemo(() => getMonths(minDate, maxDate), [minDate, maxDate])

  const [subtitle, setsubtitle] = useState('');
  const [scrollIntoView, setscrollIntoView] = useState('');
  const [currentDate, setcurrentDate] = useState<dayjs.Dayjs[] | [dayjs.Dayjs, dayjs.Dayjs | null]>(getInitialDate);

  const classnames = useMemoClassNames();
  const confirmButtonDisable = useMemo(() => {
    if (type === "range") {
      return !currentDate[0] || !currentDate[1];
    } else if (type === 'multiple') {
      return Array.isArray(currentDate) ? !currentDate.length : true
    } else {
      return !!currentDate.length
    }
  }, [type, currentDate]);

  const self = useRef<{
    contentObserver: null | Taro.IntersectionObserver
  }>({
    contentObserver: null
  })

  const scope = useScope();

  const initRect = useCallback(() => {
    if (self.current.contentObserver !== null) {
      self.current.contentObserver.disconnect()
    }
    // TODO
    if (process.env.TARO_ENV === "weapp") {
      const contentObserver = Taro.createIntersectionObserver(scope, {
        thresholds: [0, 0.1, 0.9, 1],
        observeAll: true,
      });

      contentObserver.relativeTo('.van-calendar__body');
      contentObserver.observe('.month', (res) => {
        if (res.boundingClientRect.top <= res.relativeRect.top) {
          // @ts-ignore
          const date = (res as any).dataset.date as dayjs.Dayjs;
          setsubtitle(
            (date.format('YYYY年MM月'))
          )
        }
      });
    }
  }, []);

  const onScrollIntoView = useCallback(() => {
    requestAnimationFrame(() => {
      let targetDate: dayjs.Dayjs | undefined = currentDate[0]
      const displayed = props.show || !poppable;
      if (targetDate && displayed) {
        monthslist.some((month) => {
          if (month[0].isSame(targetDate!, "month")) {
            setscrollIntoView(
              `month${month[0].format('DD/MM/YYYY')}`
            )
            return true;
          }

          return false;
        });
      }
    })
  }, [currentDate, props.show, poppable, monthslist]);

  const checkRange = useCallback((date: dayjs.Dayjs[]) => {
    if (date.length !== 2) return false;
    if (props.maxRange && date[0].clone().add(props.maxRange, 'date').isAfter(date[1])) {
      Toast({
        message: props.rangePrompt || `选择天数不能超过 ${props.maxRange} 天`,
      });
      return false
    }
    return true
  }, [props.maxRange, props.rangePrompt])

  const onConfirm = useCallback(() => {
    if (props.type === "range" && !checkRange(currentDate)) {
      return;
    }
    props.onConfirm && Taro.nextTick(() => {
      if (props.onConfirm) {
        if (props.type === "range") {
          props.onConfirm(
            [currentDate[0].clone(), currentDate[1].clone()]
          )
        } else if (props.type === "multiple") {
          props.onConfirm(
            currentDate.map(val => val.clone())
          )
        } else {
          currentDate[0] && props.onConfirm(
            currentDate[0].clone()
          )
        }
      }
    })
  }, [props.onConfirm, props.type, checkRange, currentDate]);

  const emit = useCallback((date: dayjs.Dayjs[] | [dayjs.Dayjs, dayjs.Dayjs | null]) => {
    if (props.type === "multiple" && date[1] !== null) {
      setcurrentDate(date);
      props.onSelect && props.onSelect(date as dayjs.Dayjs[])
    } else if (props.type === "range" && date.length === 2) {
      setcurrentDate(date);
      props.onSelect && props.onSelect([date[0], date[1]])
    } else if ((props.type === "single" || props.type === undefined) && date.length === 1) {
      setcurrentDate(date);
      props.onSelect && props.onSelect(date[0])
    }
  }, [props.type, props.onSelect])

  const select = useCallback((date: dayjs.Dayjs[] | [dayjs.Dayjs, dayjs.Dayjs | null], complete: boolean = false) => {

    if (complete && type === 'range' && date[1] !== null) {
      const valid = checkRange(date as dayjs.Dayjs[]);

      if (!valid) {
        // auto selected to max range if showConfirm
        if (showConfirm && props.maxRange) {
          emit([
            date[0],
            date[0].clone().set("day", props.maxRange - 1)
          ]);
        } else {
          emit(date);
        }
        return;
      }
    }
    emit(date);

    if (complete && !showConfirm) {
      onConfirm();
    }
  }, [props.type, showConfirm, onConfirm, checkRange, props.maxRange, emit]);

  const unselect = useCallback((dateArray: dayjs.Dayjs[]) => {
    if (props.onUnSelect) {
      if (dateArray.length) {
        if (props.type === "range") {
          props.onUnSelect([dateArray[0].clone(), dateArray[1].clone()])
        } else if (props.type === "multiple") {
          props.onUnSelect(dateArray.map(val => val.clone()))
        }
      }
    }
  }, [props.type, props.onUnSelect]);

  const onClickDay = useCallback((date: dayjs.Dayjs) => {

    const currentDateIsArray = Array.isArray(currentDate);

    function isNotArray(currentDate): currentDate is dayjs.Dayjs {
      return !currentDateIsArray
    }

    if (props.type === "range" && !isNotArray(currentDate)) {
      const [startDay, endDay] = currentDate;
      if (startDay && !endDay) {
        if (date.isAfter(startDay)) {
          select([startDay, date], true)
        } else if (date.isBefore(startDay)) {
          select([date, null])
        } else if (props.allowSameDay) {
          select([date, date])
        }
      } else {
        select([date, null])
      }
    } else if (type === "multiple") {
      let selectedIndex: number | undefined = undefined;

      const selected = currentDate.some((dateItem, index: number) => {
        if (dateItem === null) return false;
        const equal = dateItem[0].isSame(date) === 0;
        if (equal) {
          selectedIndex = index;
        }
        return equal;
      });

      if (selected && selectedIndex !== undefined) {
        const cancelDate = currentDate.splice(selectedIndex, 1);
        setcurrentDate(currentDate)
        unselect(cancelDate as any);
      } else {
        select([...currentDate, date] as any);
      }
    } else {
      select([date], true);
    }
  }, [props.type, currentDate, props.allowSameDay])

  useEffect(() => {
    if (props.show) {

    }
  }, [props.show])

  const Calendar = () => {
    // renderTitle 每次都能获取到当前作用域 `name` 的值
    return <View className="van-calendar">
      <VanCalHeader
        title={title}
        showTitle={showTitle}
        subtitle={subtitle}
        showSubtitle={showSubtitle}
        renderTitle={props.renderTitle}
      />
      <ScrollView className="van-calendar__body" scrollY scrollIntoView={scrollIntoView}>
        {monthslist.map((item, index) => {
          return <View
            id={`month${item[0].format('DD/MM/YYYY')}`}
            className="month"
            data-date={item[0]}
          >
            <VanCalMonth
              date={item[0]}
              type={type}
              color={props.color}
              minDate={minDay}
              maxDate={maxDay}
              showMark={showMark}
              formatter={props.formatter}
              rowHeight={rowHeight}
              currentDate={currentDate}
              showSubtitle={showSubtitle}
              allowSameDay={props.allowSameDay}
              showMonthTitle={index !== 0 || !showSubtitle}
              onClick={"onClickDay"}
            />
          </View>
        })}
      </ScrollView>
      <View className={
        classnames(
          "van-calendar__footer",
          safeAreaInsetBottom ? 'van-calendar__footer--safe-area-inset-bottom' : ''
        )
      }>
        {props.renderFooter}
      </View>
      <View className={
        classnames(
          "van-calendar__footer",
          safeAreaInsetBottom ? 'van-calendar__footer--safe-area-inset-bottom' : ''
        )
      }>
        {showConfirm && <VanButton
          round
          block
          type="danger"
          color={props.color}
          className="van-calendar__confirm"
          custom-class="van-calendar__confirm"
          disabled={confirmButtonDisable}
          onClick={onConfirm}
        >
          {confirmButtonDisable ? props.confirmDisabledText : confirmText}
        </VanButton>}
      </View>
    </View >
  }

  return <Block>
    {poppable ?
      <VanPopup
        custom-class={`van-calendar__popup--${position}`}
        className={`van-calendar__popup--${position}`}
        closeIconClass="van-calendar__close-icon"
        show={props.show} // 必为受控组件
        round={round}
        position={position}
        closeable={showTitle || showSubtitle}
        closeOnClickOverlay={props.closeOnClickOverlay}
      // bind:enter="onOpen"
      // bind:close="onClose"
      // bind:after-enter="onOpened"
      // bind:after-leave="onClosed"
      >
        {Calendar()}
      </VanPopup> :
      <Block>
        {Calendar()}

        <VanToast id="van-toast" />
      </Block>
    }
  </Block>
}

export default VanCalendar;
